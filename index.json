[
{
	"uri": "/",
	"title": "Android App On AWS",
	"tags": [],
	"description": "",
	"content": "Amplify 와 AI 서비스를 활용한 서버리스 기반 소셜 안드로이드 앱 만들기 AWS에서는 다양한 언어에 대한 기계 번역(Translate) 등 AI 기능에 대한 API 서비스를 제공합니다. 본 실습에서는 이들 서비스(Serverless) 환경으로 AWS Amplify를 활용하여 소셜 모바일 앱을 안드로이드 네이티브 기반으로 만들어 봅니다. 이를 위해 사용자 인증(Cognito), Graphql(Appsync) 등의 기능을 함께 활용합니다. 만들어진앱은 AWS Device Farm을 통해서 클라우드 상에서 테스트 할 수 있습니다. 추가적으로 AmazonPinpoint를 이용하여 사용자 이벤트를 수집하고 분석하는 기능을 활용합니다.\n"
},
{
	"uri": "/socialapp/amplifyinstall/install_cli/",
	"title": "Amplify CLI 설치",
	"tags": [],
	"description": "",
	"content": "AWS Amplify를 사용하면 AWS 기반의 확장 가능한 모바일 및 웹 앱을 손쉽게 생성, 구성 및 구현할 수 있습니다. Amplify는 모바일 애플리케이션을 위한 백엔드를 프로비저닝하고 관리합니다. 사용자가 인증, 분석, 오프라인 데이터 동기화 등 필요한 기능을 선택하기만 하면 Amplify가 각 기능을 제공하는 AWS 서비스를 자동으로 프로비저닝하고 관리합니다.\nAmplify CLI 설치를 위해서 npm을 이용합니다. npm이 설치 되어 있지 않다면\nhttps://nodejs.org/en/download/ 를 통해 설치합니다.\nAmplify CLI를 설치합니다.\nnpm install -g @aws-amplify/cli  만약 인스톨이 되지 않으면 아래와 같이 진행해보세요\nsudo npm install -g --unsafe-perm --verbose @aws-amplify/cli  Amplify에서 사용할 configure를 설정합니다.\namplify configure  amplify configure는 다음의 명령 순서에 따라 진행합니다.\n먼저 aws console 로그인 화면이 브라우저로 연결됩니다. 로그인 하시고 Enter 를 입력하세요.\n본 워크샵은 us-east-1 에서 진행됩니다. Default Region을 us-east-1 을 넣으세요.\nUser name에는 새롭게 생성하실 IAM 사용자를 입력합니다.\n로그인된 브라우저를 통해 aws console의 사용자 추가 화면으로 이동합니다.\n마지막 create user 까지 default로 설정을 그대로 놔두면서 아래 화면까지 이동합니다.\nDownload .csv 를 로컬에 저장합니다.\nEnter 를 입력하시고 Access Key와 Secret Access Key 를 차례대로 입력합니다. Access Key와 Secret Access Key 는 download받으신 scv파일이나 사용자 추가 화면에서 가져오실 수 있습니다.\nProfile Name은 default로 사용하시거나 별도의 이름을 주어 \u0026ndash;profile옵션으로 활용하실 수 있습니다. us-east-1-profile 이라고 넣습니다. (원하는 이름을 넣으셔도 됩니다.)\n"
},
{
	"uri": "/socialapp/amplifyinstall/",
	"title": "Android Amplify 초기화",
	"tags": [],
	"description": "",
	"content": " Android Amplify 초기화 생성된 sample application의 손쉬운 Back-end개발을 위해 Android Amplify와 연동하겠습니다.\n"
},
{
	"uri": "/socialapp/amplifyinstall/amplifyinit/",
	"title": "Amplify 초기화",
	"tags": [],
	"description": "",
	"content": "다운받은 sample app의 root directory로 이동 후 Amplify 프로젝트를 초기화 합니다\ncd aws-android-workshop/ amplify init  프로젝트 이름은 default를 사용하기 위해 Enter 를 입력합니다.\nenvironment는 dev,\neditor는 편하신 것을 선택합니다. 여기서는 vim 을 사용하도록 하겠습니다.\nos type은 Android\nres directory는 default를 사용하기 위해 Enter를 입력합니다.\nAWS Profile을 사용하겠다고 선택(Y) 하시고, 이미 생성하신 프로파일을 선택합니다. us-east-1-profile\n아래와 그림을 참고하셔서 입력하십시요.\nAmplify init이 수행 완료 되면 인증된 사용자와 비인증사용자를 위한 IAM role이 자동생성됩니다. 아래와 같이 2개의 IAM role이 생성된 것을 확인할 수 있습니다.\nAWS console \u0026gt; service \u0026gt; IAM \u0026gt; Role \u0026gt; 검색창에 aws-android-workshop-dev \n또한 안드로이드 스튜디오에서 res/raw/awsconfiguration.json.file 파일이 생성된 것을 확인하실 수 있습니다.\n이제 Amplify CLI command를 통해 다양한 AWS Service를 생성 하실 수 있습니다.\ncommand는 다음을 같이 사용하실 수 있습니다.\n amplify add \u0026lt;category\u0026gt; amplify remove \u0026lt;category\u0026gt; amplify push \u0026lt;category\u0026gt;  "
},
{
	"uri": "/socialapp/cognito/",
	"title": "회원관리 기능 구현하기",
	"tags": [],
	"description": "",
	"content": " 회원관리 기능 구현하기 이제 가입된 사용자만 소셜 어플리케이션을 사용할 수 있도록 Amazon Cognito를 이용한 회원 관리 기능을 구현해 보겠습니다. 실습은 Facebook을 통한 소셜 인증 방식과 이메일을 통한 인증방식으로 구성됩니다.\n"
},
{
	"uri": "/socialapp/appsync/",
	"title": "소셜 게시물 저장소 만들기",
	"tags": [],
	"description": "",
	"content": " 소셜 게시물 저장소 만들기 AWS AppSync를 활용하여 데이타 저장소 및 접근 API를 생성하여 어플리케이션 개발을 간소화 합니다.\n"
},
{
	"uri": "/cleanup/delete/",
	"title": "리소스 삭제",
	"tags": [],
	"description": "",
	"content": "아래 명령어를 이용해 리소스를 한번에 삭제합니다.\namplify delete amplify push  사진이 업로드된 S3의 버킷을 삭제합니다.\nPinpoint프로젝트를 삭제합니다.\npinpoint\u0026gt;project\u0026gt;settings\u0026gt;General settings\u0026gt;Delete project\n"
},
{
	"uri": "/socialapp/cognito/facebook-config/",
	"title": "Facebook OAuth 설정하기",
	"tags": [],
	"description": "",
	"content": "Facebook을 통한 로그인을 지원하기 위해 Facebook 개발자 사이트에 OAuth 관련 설정을 진행해 보겠습니다.\n실습에서는 Amazon Cognito가 제공하는 Hosted UI 방식을 이용하여 OAuth2.0 연동을 구성하겠습니다. 이 방식을 이용할 경우 별도의 Facebook SDK 설치 없이 간단한 설정만으로 소셜 인증 기능을 구현하실 수 있습니다.\n Facebook에 개발자 계정을 생성합니다. 자신의 Facebook 계정으로 페이스북에 로그인 한다. My App 메뉴에서 Create App을 선택한다.  Facebook app 이름(AWSAndroidWorkshop)을 입력하고 Create App ID를 선택한다.  좌측 네비게이션 바에서 Settings \u0026gt; Basic을 선택한다.  다음 실습에서 Facebook 인증 정보로 활용하기 위해 App ID와 App Secret을 기록해 둔다.\n  "
},
{
	"uri": "/socialapp/pinpoint/fcm-settings/",
	"title": " Firebase Cloud Messaging (FCM)설정하기",
	"tags": [],
	"description": "",
	"content": "Amazon Pinpoint는 push notification을 보내기 위해 Firebase Cloud Messaging (FCM) 을 사용합니다. 이를 위해 firebase project를 생성해야 합니다.\nhttps://console.firebase.google.com/ 페이지로 이동합니다.\n만약 Google계정을 없거나 sign out되어 있다면 sign in 하십시요\nCreate a project 를 선택하십시요. 프로젝트 이름을 넣으시고 계속 을 눌러 다음단계로 이동합니다.\n본 워크샵은 FCM을 push message 용도로만 사용할 예정이기 때문에 Emable Google Analytics for this project 를 disable하고 다음단계로 이동합니다.\nproject가 생성되면 아래와 같은 화면이 보이게 됩니다. 왼쪽 상단에 설정 아이콘인 톱니바퀴 모양의 아이콘을 선택하고 Project settings 를 선택합니다.\nGeneral 탭에 아래부분에 Your apps 가 있습니다. 안드로이드 모양의 아이콘을 선택합니다.\nPackage name(com.example.socialandroidapp)과 nickname(aws-android-workshop)을 각각 아래와 같이 입력합니다. Register app 버튼을 눌러 다음단계로 이동합니다.\n화면에 보이는 Download 버튼을 통해 json 파일을 그림을 참고하여 해당 경로에 download합니다.\n이후 모두 default로 선택 하신 후 완료합니다.\nSettings로 돌아와서 두번째 탭인 Cloud Messaging 을 선택합니다.\nServer key 에 해당하는 값을 복사 하십시요. 다음 장에서 필요합니다.\n"
},
{
	"uri": "/socialapp/cognito/amplify-cognito/",
	"title": "Amazon Cognito Service 만들기",
	"tags": [],
	"description": "",
	"content": "Amazon Cognito를 사용하면 모바일 앱에 빠르고 손쉽게 사용자 가입, 로그인 및 액세스 제어 기능을 추가할 수 있습니다.\n안드로이드 프로젝트 최상위 위치에서 다음 명령을 실행합니다.\namplify add auth  진행 중 선택항목은 아래 그림의 내용을 참고하세요.\ndomain name 설정 시 aws, amazon, cognito 및 _를 포함한 이름은 사용하실 수 없습니다. \u0026lsquo;android-workshop+랜덤문자\u0026rsquo; 형태로 이름을 입력해주셔야 합니다.\nredirect URI는 아래와 같이 입력합니다.\nredirect signin URI :\nsocialdemoapp://callback/  redirect signout URI :\nsocialdemoapp://signout/  social providers 에서 facebook 선택시 Space bar 를 이용해 선택할 수 있습니다.\nApp ID와 App Secret 정보는 앞단계에서 생성한 Facebook 인증 정보의 App ID와 App Secret를 사용합니다.\nDo you want to configure advanced settings for the GraphQL API?에서는 No를 선택합니다.\n완료되면 다음 명령어를 통해 관련된 AWS 리소스를 업데이트 합니다.\namplify push  정상적으로 필요한 자원이 생성된 경우 아래 그림과 같이 Hosted UI Endpoint를 확인할 수 있습니다. Cognito User Pool이 생성된 것을 확인하기 위해 AWS 관리 콘솔(AWS console \u0026gt; Services \u0026gt; Cognito \u0026gt; User Pools)에 접속합니다. 또한 안드로이드 스튜디오에서 res/raw/awsconfiguration.json 파일에 각 환경설정 값들이 생성된 것을 확인하실 수 있습니다. 마지막으로, Facebook 개발자 사이트에 접속하여 생성한 Cognito 도메인 정보를 업데이트 합니다.\n Facebook 개발자 사이트에서 이전 장에서 생성한 앱(AWSAndroidWorkshop)을 선택합니다.\n 좌측 네비게이션 바에서 Settings \u0026gt; Basic을 선택합니다. App Domains에 Amplify CLI 실행 결과 출력된 Hosted UI Endpoint (Cognito의 User Pool Domain Name과 동일한 값으로 AWS 관리 콘솔의 메뉴[AWS console \u0026gt; Services \u0026gt; Cognito \u0026gt; User Pools \u0026gt; Domain Name]에서도 확인 가능) 값을 저장합니다. https://\u0026lt;your-user-pool-domain\u0026gt;  Facebook 개발자 사이트의 Dashboard 메뉴로 이동합니다. Add a Product에서 Facebook Login 항목의 Set Up 버튼을 선택합니다.  Facebook 개발자 사이트의 Products \u0026gt; Facebook Login \u0026gt; Settings 항목으로 이동합니다. Embedded Browser OAuth Login을 활성화 하고, Valid OAuth Redirects URIs에 아래 형식의 URI를 입력 후, Save Changes를 클릭합니다. https://\u0026lt;your-user-pool-domain\u0026gt;/oauth2/idpresponse   "
},
{
	"uri": "/socialapp/appsync/amplify-appsync/",
	"title": "저장소 생성 및 API 생성",
	"tags": [],
	"description": "",
	"content": "Amplify를 이용하여 api를 추가합니다.\namplify add api  입력값은 아래 그림을 참고하여 넣습니다. API인가를 위해 Amazon Cognito User Pool을 선택합니다. Amazon Cognito에 가입하고 로그인한 사용자의 경우 AWS 리소스접근에 대한 인가를 부여합니다. Api 접근시에도 인가가 필요한데, 이 인가 방법으로 cognito를 사용한다는 의미입니다.\n과정 중 스키마를 입력하는 부분이 나옵니다. amplify init 시 설정하신 에디터가 스키마를 입력하는 단계에서 자동으로 뜹니다.\n윈도우 사용자에 경우 선택하신 에디터가 없을 경우가 많습니다. 해당하는 에디터가 없을 경우 스키마 입력 창이 뜨지 않고 amplify add api가 종료되는데, 이 경우 콘솔창 메시지에서 보이는 path로 직접 이동하셔서 해당 파일을 에디터로 열어주세요.\nExample : amplify\\backend/api/awsandroidworkshop/schema.graphql\n스키마를 입력하는 에디터에는 ToDo 스키마가 미리 들어가 있습니다. 이는 샘플스키마로 모두 삭제하신후 아래 스키마로 바꿔주세요.\n스키마는 아래 값을 사용합니다.\n아래 @model 을 사용하시면 DynamoDB table, AppSync DataSource, IAM role, AppSync Resolvers등을 생성해줍니다. @key에 의해 DynamoDB의 파티션키와 정렬키를 생성합니다. 즉, DEV-DAY로 생성된 Post중 upload time으로 정렬을 하는데 사용할 예정입니다.\ntype Mutation { putPostWithPhoto( id: String!, author: String!, title: String, content: String, url: String, uptime: String!, photo: S3ObjectInput version: Int! ): Post } type S3Object { bucket: String! key: String! region: String! } input S3ObjectInput { bucket: String! key: String! region: String! localUri: String mimeType: String } type Post @model @key(fields:[\u0026quot;id\u0026quot;,\u0026quot;uptime\u0026quot;]){ id: String! author: String! title: String content: String url: String uptime: String! photo: S3Object version: Int! }  amplify add api 가 완료되면 클라우드리소스 생성을 위해 push합니다.\namplify push  필요한 입력값은 default 선택 후 Enter 하십시요\nAWS console \u0026gt; service \u0026gt; AppSync 에 들어가보시면 다음과 같이 api가 생성된 것을 확인하실 수 있습니다.\n또한 AWS console \u0026gt; service \u0026gt; AppSync \u0026gt;Data Sources 에 들어가보시면 Dynamodb가 생성되고 Data Source로 연동된 모습을 확인하실 수 있습니다.\n이제 Mutation 에 새로 추가한 api를 dynamodb와 연계할 수 있는 Resolver를 변경 해보겠습니다. AWS console \u0026gt; service \u0026gt; AppSync \u0026gt;Schema에서 Resolvers중 putPostWithPhoto(..) 를 찾아 Attach를 누릅니다.\nData source name에 PostTable 를 선택합니다. Configure the request mapping template은 Put item with S3 ObjectPut 를 선택하세요.\n불러 온 템플릿의 key 부분을 아래와 같이 수정합니다. 소스로 부터 전달받은 id를 사용하겠다는 의미입니다.\n\u0026quot;key\u0026quot; : { \u0026quot;id\u0026quot; : { \u0026quot;S\u0026quot; : \u0026quot;$ctx.args.id\u0026quot; } },  Configure the response mapping template은 기존의 코드를 삭제하시고 아래와 같이 작성합니다.\n그리고 Save Resolver을 눌러 저장합니다.\n$util.toJson($util.dynamodb.fromS3ObjectJson($context.source.file))  안드로이드 스튜디오에서 res/raw/awsconfiguration.json 파일이 생성된 것을 확인하실 수 있습니다.\nAmplify codegen을 통해 를 이용하여 생성된 코드를 안드로이드 프로젝트 폴더에 다운로드 합니다.\namplify codegen  실제 저장되는 저장공간인 S3에 버킷을 생성합니다.\nAWS console \u0026gt; service \u0026gt; S3 로 이동합니다.\n파란색 버튼  버킷만들기 를 선택합니다.\n버킷이름을 넣고 생성을 누르세요. 이때 버킷이름은 global하게 unique해야합니다.\n"
},
{
	"uri": "/prerequisites/",
	"title": "워크샵 시작하기",
	"tags": [],
	"description": "",
	"content": " 워크샵 시작 본 워크샵은 AWS 계정을 가지고 계신 분을 대상으로 진행합니다.\n샘플코드는 안드로이드 - JAVA 기반으로 제작되었습니다.\n코틀린(Kotlin) 사용자를 위한 샘플 코드는 별로로 제공되지 않습니다.\n\n"
},
{
	"uri": "/socialapp/appsync/android-appsync/",
	"title": "게시물 작성하기 ",
	"tags": [],
	"description": "",
	"content": "이제 안드로이드 프로젝트에 게시물 작성 하기 액티비티와 연동해보도록 하겠습니다.\nbuild.gradle (Module: Project) 에 아래와 같이 dependencies에 classpath를 추가 합니다.\nclasspath 'com.amazonaws:aws-android-sdk-appsync-gradle-plugin:2.9.+'  build.gradle (Module: app) 에 plugin을 적용시킵니다. build.gradle (Module: app) 상단에 아래와 같이 복사해서 붙여 넣습니다. 이 plugin에 의해 코드가 자동생성됩니다.\napply plugin: 'com.amazonaws.appsync'  참고로 apply plugin: \u0026lsquo;com.amazonaws.appsync\u0026rsquo;를 추가할 때 싱크 문제 때문에 com.amazonaws.appsync not found 문제가 뜰 수 있습니다. classpath \u0026lsquo;com.amazonaws:aws-android-sdk-appsync-gradle-plugin:2.9.+\u0026lsquo;를 추가 후에 싱크를 한번 해 주고 나서 apply plugin 을 해주면 정상적으로 수행 됩니다.\n또한 같은 파일에 -build.gradle (Module: app)- 에 아래와 같이 dependencies에 4개의 implementation을 추가 합니다.\ndependencies { ... implementation 'com.amazonaws:aws-android-sdk-appsync:2.9.+' implementation 'org.eclipse.paho:org.eclipse.paho.client.mqttv3:1.2.0' implementation 'org.eclipse.paho:org.eclipse.paho.android.service:1.1.1' implementation 'com.amazonaws:aws-android-sdk-s3:2.14.+' ... }  다음으로 자주 사용되는 AWSAppSyncClient 를 재사용하기 위해 ClientFactory class를 아래와 같이 생성합니다.\nClientFactory.java\npackage com.example.socialandroidapp; import android.content.Context; import android.util.Log; import com.amazonaws.auth.AWSCredentials; import com.amazonaws.auth.AWSCredentialsProvider; import com.amazonaws.auth.CognitoCachingCredentialsProvider; import com.amazonaws.mobile.client.AWSMobileClient; import com.amazonaws.mobile.config.AWSConfiguration; import com.amazonaws.mobileconnectors.appsync.AWSAppSyncClient; import com.amazonaws.mobileconnectors.appsync.S3ObjectManagerImplementation; import com.amazonaws.mobileconnectors.appsync.sigv4.CognitoUserPoolsAuthProvider; import com.amazonaws.regions.Region; import com.amazonaws.services.s3.AmazonS3Client; public class ClientFactory { private static AWSAppSyncClient mAWSAppSyncClient; public static void appSyncInit(Context context) { if (mAWSAppSyncClient == null) { mAWSAppSyncClient = AWSAppSyncClient.builder() .context(context) .awsConfiguration(new AWSConfiguration(context)) .cognitoUserPoolsAuthProvider(new CognitoUserPoolsAuthProvider() { @Override public String getLatestAuthToken() { try { return AWSMobileClient.getInstance().getTokens().getIdToken().getTokenString(); } catch (Exception e) { Log.e(\u0026quot;APPSYNC_ERROR\u0026quot;, e.getLocalizedMessage()); return e.getLocalizedMessage(); } } }).s3ObjectManager(getS3ObjectManager(context)).build(); } } public static AWSAppSyncClient getAppSyncClient() { return mAWSAppSyncClient; } private static S3ObjectManagerImplementation s3ObjectManager; // Copy the below two methods and add the .s3ObjectManager builder parameter // initialize and fetch the S3 Client public static S3ObjectManagerImplementation getS3ObjectManager(final Context context) { if (s3ObjectManager == null) { AmazonS3Client s3Client = new AmazonS3Client(ClientFactory.getCredentialsProvider(context)); s3Client.setRegion(Region.getRegion(\u0026quot;us-east-1\u0026quot;)); // you can set the region of bucket here s3ObjectManager = new S3ObjectManagerImplementation(s3Client); } return s3ObjectManager; } // initialize and fetch cognito credentials provider for S3 Object Manager public static AWSCredentialsProvider getCredentialsProvider(final Context context) { CognitoCachingCredentialsProvider credentialsProvider = new CognitoCachingCredentialsProvider( context, AWSMobileClient.getInstance().getConfiguration() ); return credentialsProvider; } public static String getUserID() { return AWSMobileClient.getInstance().getUsername(); } public static AWSCredentials getAWSCredentials() { AWSCredentials awsCredentials = null; try { awsCredentials = AWSMobileClient.getInstance().getAWSCredentials(); } catch (Exception e) { e.printStackTrace(); } return awsCredentials; } }  WriteActivity.java 의 onCreate 함수에서 위에서 생성한 ClientFactory 이용하여 AWSAppSyncClient를 생성합니다.\nonCreate()함수에 아래와 같이 ClientFactory.appSyncInit(..) 를 추가하세요.\n@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.write); //appsync ClientFactory.appSyncInit(getApplicationContext()); ... }  WriteActivity.java에서 DONE 버튼으로 게시물을 업로드 할경우 저장소에 게시물이 저장될 수 있도록 addComment 함수를 추가합니다. 아래 소스를 복사해서 넣으신 후 putYourBucketName 변수값을 여러분의 S3 버킷 이름으로 교체 하세요\n//appsync upload private final String putYourBucketName = \u0026quot;putYourBucketName\u0026quot;; private final String mimeType = \u0026quot;image/jpg\u0026quot;; private final String region = \u0026quot;us-east-1\u0026quot;; private final String folderName = \u0026quot;public/\u0026quot;; private void addComment() { showWaitDialog(); S3ObjectInput s3ObjectInput = S3ObjectInput.builder() .bucket(putYourBucketName) .key(folderName + UUID.randomUUID().toString()) .region(region) .localUri(bitmapPath) .mimeType(mimeType).build(); PutPostWithPhotoMutation addPostMutation = PutPostWithPhotoMutation.builder() .title(title.getText().toString()) .author(ClientFactory.getUserID()) .url(bitmapPath) .content(contents.getText().toString()) .uptime(String.valueOf(System.currentTimeMillis())) .photo(s3ObjectInput) .id(\u0026quot;DEV-DAY\u0026quot;) .build(); ClientFactory.getAppSyncClient().mutate(addPostMutation).enqueue(postsCallback); } private GraphQLCall.Callback\u0026lt;PutPostWithPhotoMutation.Data\u0026gt; postsCallback = new GraphQLCall.Callback\u0026lt;PutPostWithPhotoMutation.Data\u0026gt;() { @Override public void onResponse(@Nonnull final Response\u0026lt;PutPostWithPhotoMutation.Data\u0026gt; response) { runOnUiThread(new Runnable() { @Override public void run() { dismissWaitDialog(); WriteActivity.this.finish(); } }); } @Override public void onFailure(@Nonnull final ApolloException e) { runOnUiThread(new Runnable() { @Override public void run() { dismissWaitDialog(); Log.e(\u0026quot;\u0026quot;, \u0026quot;Failed to perform AddPostMutation\u0026quot;, e); WriteActivity.this.finish(); } }); } };  필요한 class를 import 합니다.\nimport com.amazonaws.amplify.generated.graphql.PutPostWithPhotoMutation; import com.apollographql.apollo.GraphQLCall; import com.apollographql.apollo.api.Response; import com.apollographql.apollo.exception.ApolloException; import type.S3ObjectInput;  기존의 코드인 WriteActivity.this.finish() 는 지우시고, 그자리에 addComment()를 넣으세요.\n@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.write); //appsync ClientFactory.appSyncInit(getApplicationContext()); ... saveBtn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { if (bitmapPath == null) { Toast.makeText(getApplicationContext(), getString(R.string.warning_picture), Toast.LENGTH_SHORT).show(); return; } //WriteActivity.this.finish(); addComment(); } }); ... }  이 함수는 onCreate함수의 saveBtn에 onClick event시 호출될 수 있도록 합니다.\n기존의 코드인 WriteActivity.this.finish() 는 지우시고, 그자리에 addComment()를 넣으세요.\n@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.write); //appsync ClientFactory.appSyncInit(getApplicationContext()); ... saveBtn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { if (bitmapPath == null) { Toast.makeText(getApplicationContext(), getString(R.string.warning_picture), Toast.LENGTH_SHORT).show(); return; } //WriteActivity.this.finish(); addComment(); } }); ... }  안드로이드 스튜디오 프로젝트 상단에 실행버튼 을 눌러 이미 생성하신 에뮬레이터로 어플리케이션을 실행합니다. 실행된 화면은 다음과 같습니다. 로긴을 하시고, 만약 로긴이 된 상태라면 아래 처럼 빈 리스트화면이 나타납니다.\n글쓰기 버튼을 눌러 게시작성 화면으로 이동하신후 아래처럼 작성 및 사진을 업로드하고, done 버튼을 누르세요.\n이때 에뮬레이터를 처음 설치하셨다면 선택할수있는 사진이 없습니다. 카메라 어플로 이동하신 후 더미 사진을 한잔 찍고 나면 사진을 선택하실 수 있습니다.\n잠시후 빈 리스트화면으로 이동됩니다.\n"
},
{
	"uri": "/socialapp/cognito/cognito-splash/",
	"title": "앱 시작 화면 만들기",
	"tags": [],
	"description": "",
	"content": "이번 실습에서는 앱의 시작화면을 구성해 봅니다. 시작화면에서는 Cognito의 로그인 상태를 확인하는 코드가 추가가 됩니다. 기존 로그인 정보가 없는 경우는 로그인 메인 화면으로 이동하고, 로그인 정보가 있는 경우는 앱 메인 화면으로 이동합니다.\n아래 코드 부분을 복사하여 _initCognito 메소드를 완성해 봅니다.\n// SplashActivity.java public class SplashActivity extends AppCompatActivity { ... private void _initCognito() { // Add code here if (AWSMobileClient.getInstance().getConfiguration() == null){ // Initialize user AWSMobileClient.getInstance().initialize(getApplicationContext(), new Callback\u0026lt;UserStateDetails\u0026gt;() { @Override public void onResult(UserStateDetails userStateDetails) { switch (userStateDetails.getUserState()){ case SIGNED_IN: // Open Main Activity CommonAction.openMain(context); break; case SIGNED_OUT: Log.d(TAG, \u0026quot;Do nothing yet\u0026quot;); CommonAction.openAuthMain(context); break; default: AWSMobileClient.getInstance().signOut(); break; } } @Override public void onError(Exception e) { Log.e(\u0026quot;INIT\u0026quot;, e.toString()); } }); } else if (AWSMobileClient.getInstance().isSignedIn()){ // Logined user CommonAction.openMain(context); } else { // Logouted user CommonAction.openAuthMain(context); } } ... }  안드로이드 스튜디오 프로젝트 상단에 실행버튼 을 눌러 이미 생성하신 에뮬레이터로 어플리케이션을 실행합니다. 앱이 정상 실행되면 로그인 여부를 확인하는 로직이 포함된 시작화면이 표시됩니다. 로그인 상태 확인이 정상적으로 완료된 경우에는 아래와 같은 인증 메인화면으로 이동하게 됩니다. "
},
{
	"uri": "/socialapp/cognito/cognito-auth-social/",
	"title": "소셜 로그인 기능 구현하기",
	"tags": [],
	"description": "",
	"content": "이번 실습에는 Cognito의 Hosted UI 기능을 사용해 페이스북 기반 소셜 로그인 기능을 구현해 보겠습니다.\nHosted UI를 이용하면 OAuth2 인증이 Server to Server로 에 진행되기 때문에 페이스북에서 제공하는 별도의 모바일 SDK를 설치하실 필요는 없습니다. 현재 Hosted UI를 이용해 인증 가능한 Identity Provider는 Facebook, Google, Amazon입니다.\n아래 코드를 복사하여 Facebook 로그인을 위한 Hosted UI기능 추가를 위한 _openFacebookLogin 메소드를 완성해 봅니다.\n// AuthMainActivity.java public class AuthMainActivity extends AppCompatActivity { ... private void _openFacebookLogin() { // Add code here HostedUIOptions hostedUIOptions = HostedUIOptions.builder() .scopes(\u0026quot;openid\u0026quot;, \u0026quot;email\u0026quot;) .identityProvider(\u0026quot;Facebook\u0026quot;) .build(); SignInUIOptions signInUIOptions = SignInUIOptions.builder() .hostedUIOptions(hostedUIOptions) .build(); AWSMobileClient.getInstance().showSignIn((Activity) context, signInUIOptions, new Callback\u0026lt;UserStateDetails\u0026gt;() { @Override public void onResult(UserStateDetails details) { Log.d(TAG, \u0026quot;onResult: \u0026quot; + details.getUserState()); } @Override public void onError(Exception e) { Log.e(TAG, \u0026quot;onError: \u0026quot;, e); } }); } ... }  다음으로, 소셜 인증 완료 후 호출된 callback 정보(socialdemoapp://callback/)을 감지하여 해당 이벤트를 처리하는 코드를 추가합니다. 실습에서는 해당 scheme 호출 시 앱 메인으로 이동하는 기능을 구현합니다.\n\u0026lt;!-- AndroidManifest.xml --\u0026gt; \u0026lt;activity android:name=\u0026quot;.AuthMainActivity\u0026quot; android:screenOrientation=\u0026quot;portrait\u0026quot; android:theme=\u0026quot;@style/AppTheme.NoActionBar\u0026quot;\u0026gt; \u0026lt;!-- Add code here--\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026quot;android.intent.action.VIEW\u0026quot; /\u0026gt; \u0026lt;category android:name=\u0026quot;android.intent.category.DEFAULT\u0026quot; /\u0026gt; \u0026lt;category android:name=\u0026quot;android.intent.category.BROWSABLE\u0026quot; /\u0026gt; \u0026lt;data android:scheme=\u0026quot;socialdemoapp\u0026quot; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt;  // AuthMainActivity.java public class AuthMainActivity extends AppCompatActivity { ... @Override protected void onResume() { super.onResume(); // Add code here Intent activityIntent = getIntent(); if (activityIntent.getData() != null \u0026amp;\u0026amp; \u0026quot;socialdemoapp\u0026quot;.equals(activityIntent.getData().getScheme())) { if (AWSMobileClient.getInstance().handleAuthResponse(activityIntent)) CommonAction.checkSession(this, true); } } ... }  안드로이드 스튜디오 프로젝트 상단에 실행버튼 을 눌러 이미 생성하신 에뮬레이터로 어플리케이션을 실행합니다. 아래와 같은 화면이 나오면 페이스북으로 시작 버튼을 눌러서 페이스북 로그인을 진행해 봅니다. 에뮬레이터에서 최초 실행할 경우 아래와 같은 페이스북 로그인 화면이 나오는 경우, 반드시 이전 실습에서 만든 페이스북 개발자 계정 정보를 입력합니다. 페이스북 앱이 개발모드로 설정되어 있어 다른 계정을 사용한 경우 \u0026lsquo;앱 설정 안 됨\u0026rsquo;이라는 오류 메시지가 나오고 로그인에 실패하게 됩니다. 로그인이 정상적으로 이루어진 경우 아래와 같은 앱 메인화면으로 이동하게 됩니다. Cognito Hosted UI를 통해 서버간 소셜 인증이 정상적으로 이루어진 경우, 다음과 같이 Cognito User Pool에 사용자의 정보가 저장되게 됩니다. 저장된 사용자 정보 확인은 AWS Console \u0026gt; Cognito \u0026gt; General Settings \u0026gt; Users and groups에 Users 탭의 내용을 통해 확인하실 수 있습니다. (콘솔에서 사용자 정보를 하는데는 경우에 따라 1분 정도 시간이 소용되는 경우도 있습니다) 실습을 마무리 한 경우, 다음 실습을 위해 로그아웃을 진행합니다.\n 앱 메인 화면의 SETTINGS 버튼을 선택  앱 설정 화면의 LOGOUT 버튼을 선택   "
},
{
	"uri": "/socialapp/cognito/cognito-auth-email/",
	"title": "이메일 기반 회원 가입 기능 구현하기",
	"tags": [],
	"description": "",
	"content": "이번 실습에서는 이메일 기반 회원 가입 기능을 구현해 보겠습니다.\n실습 시작 전, AWS Conginto 관리 콘솔에 접근해 이메일이 로그인 방법으로 지정되어 있는지 확인해보도록 하겠습니다. AWS 관리 콘솔의 Attributes 항목의 내용이 아래 그림과 같이 설정되어 있는지 확인합니다. 이제 단계별로 이메일 기반 회원 가입을 위한 코드를 완성해 보겠습니다.\n 입력받은 이메일, 비밀번호를 이용해 회원 가입을 진행. 아래 코드를 복사하여 회원 가입을 위한 signUp 메소드를 완성합니다. signUp 메소드에서는 입력받은 이메일과 비밀번호로 Cognito user pool에 새로운 사용자를 추가합니다. 사용자 정보가 정상 등록된 경우에는 사용자 이메일 인증을 위한 SignUpConfirmFragment로 화면을 전환합니다.\n// SignUpActivity.java public class SignUpActivity extends FragmentActivity implements SignUpFragment.OnFragmentInteractionListener, SignUpConfirmFragment.OnFragmentInteractionListener { ... @Override public void signUp(String email, String password) { userName = email; this.password = password; // Add code here final Map\u0026lt;String, String\u0026gt; attributes = new HashMap\u0026lt;\u0026gt;(); attributes.put(\u0026quot;email\u0026quot;, email); AWSMobileClient.getInstance().signUp(userName, password, attributes, null, new Callback\u0026lt;SignUpResult\u0026gt;() { @Override public void onResult(final SignUpResult signUpResult) { runOnUiThread(() -\u0026gt; { if (!signUpResult.getConfirmationState()) { final UserCodeDeliveryDetails details = signUpResult.getUserCodeDeliveryDetails(); makeToast(context, \u0026quot;Confirm sign-up with: \u0026quot; + details.getDestination()); setSignUpConfirmFragment(); } else { makeToast(context, \u0026quot;Sign-up done.\u0026quot;); } }); } @Override public void onError(Exception e) { Log.e(TAG, \u0026quot;Sign-up error\u0026quot;, e); runOnUiThread(() -\u0026gt; { if (e instanceof AmazonServiceException) makeToast(context, ((AmazonServiceException) e).getErrorMessage()); }); } }); } ... }  이메일 인증. 1 단계에서 회원가입에 성공한 경우 이메일로 인증 코드가 발송됩니다. 아래 코드를 복사하여 이메일과 인증코드를 입력받아 회원 가입 단계를 마무리하는 confirmSignUp 메소드를 완성합니다.\n// SignUpActivity.java public class SignUpActivity extends FragmentActivity implements SignUpFragment.OnFragmentInteractionListener, SignUpConfirmFragment.OnFragmentInteractionListener { ... @Override public void confirmSignUp(String code) { // Add code here AWSMobileClient.getInstance().confirmSignUp(userName, code, new Callback\u0026lt;SignUpResult\u0026gt;() { @Override public void onResult(final SignUpResult signUpResult) { runOnUiThread(() -\u0026gt; { Log.d(TAG, \u0026quot;Sign-up callback state: \u0026quot; + signUpResult.getConfirmationState()); if (!signUpResult.getConfirmationState()) { final UserCodeDeliveryDetails details = signUpResult.getUserCodeDeliveryDetails(); makeToast(context,\u0026quot;Confirm sign-up with: \u0026quot; + details.getDestination()); } else { makeToast(context, \u0026quot;Sign-up done.\u0026quot;); // SignIn and move to MainActivity _signIn(userName, password); } }); } @Override public void onError(Exception e) { Log.e(TAG, \u0026quot;Confirm sign-up error\u0026quot;, e); runOnUiThread(() -\u0026gt; { if (e instanceof AmazonServiceException) makeToast(context, ((AmazonServiceException) e).getErrorMessage()); }); } }); } ... }  자동 로그인. 이메일 인증이 완료된 경우, 가입 단계에서 사용한 이메일과 비밀번호를 이용하여 자동 로그인 기능을 수행하는 _signIn 함수를 완성합니다.\n// SignUpActivity.java public class SignUpActivity extends FragmentActivity implements SignUpFragment.OnFragmentInteractionListener, SignUpConfirmFragment.OnFragmentInteractionListener { ... private void _signIn(String username, String password) { // Add code here AWSMobileClient.getInstance().signIn(username, password, null, new Callback\u0026lt;SignInResult\u0026gt;() { @Override public void onResult(final SignInResult signInResult) { runOnUiThread(() -\u0026gt; { Log.d(TAG, \u0026quot;Sign-in callback state: \u0026quot; + signInResult.getSignInState()); switch (signInResult.getSignInState()) { case DONE: makeToast(context, \u0026quot;Sign-in done.\u0026quot;); CommonAction.openMain(context); break; case SMS_MFA: makeToast(context, \u0026quot;Please confirm sign-in with SMS.\u0026quot;); break; case NEW_PASSWORD_REQUIRED: makeToast(context, \u0026quot;Please confirm sign-in with new password.\u0026quot;); break; default: makeToast(context, \u0026quot;Unsupported sign-in confirmation: \u0026quot; + signInResult.getSignInState()); break; } }); } @Override public void onError(Exception e) { Log.e(TAG, \u0026quot;Sign-in error\u0026quot;, e); runOnUiThread(() -\u0026gt; { if (e instanceof AmazonServiceException) makeToast(context, ((AmazonServiceException) e).getErrorMessage()); }); } }); } ... }   이제 작성한 코드를 실행해 보도록 하겠습니다.\n안드로이드 스튜디오 프로젝트 상단에 실행버튼을 눌러 에뮬레이터로 어플리케이션을 실행합니다. 아래와 같은 화면이 나오면 회원가입 텍스트를 눌러서 이메일 기반 회원 가입 메뉴로 이동합니다. 아래와 같은 화면이 나오면 이메일과 비밀번호를 입력하여 회원 가입을 진행합니다. 이메일 인증 과정이 필수로 적용되어 있기 때문에 수신 가능한 이메일 계정을 사용해주시기 바랍니다. 이메일 수신함을 확인하여 Cognito 서비스에서 발송된 인증 코드를 확인합니다. 인증코드 입력화면에서 이메일로 전달 받은 인증코드를 입력합니다. 회원가입이 정상적으로 이루어진 경우 아래와 같은 앱 메인화면으로 이동하게 됩니다. 가입된 사용자 정보는 AWS 관리 콘솔의 Cognito 메뉴를 통해 확인 가능합니다. 실습을 마무리 한 경우, 다음 실습을 위해 로그아웃을 진행합니다.\n 앱 메인 화면의 SETTINGS 버튼을 선택  앱 설정 화면의 LOGOUT 버튼을 선택   "
},
{
	"uri": "/socialapp/appsync/s3iam/",
	"title": "IAM 권한 주기",
	"tags": [],
	"description": "",
	"content": "Write 화면에서 작성된 게시물은 AWS console \u0026gt; service \u0026gt; Dynamodb  에 생성된 table에 추가가 되어 있지 않습니다. 아래 로그로 인해 업로드 되지 않았는데요, 바로 S3에 대한 AccessDenied이 원인입니다.\n2019-09-04 11:13:55.305 8048-8081/com.example.socialandroidapp D/EGL_emulation: eglMakeCurrent: 0xe1005300: ver 3 0 (tinfo 0xe10036b0) 2019-09-04 11:13:55.321 8048-8057/com.example.socialandroidapp W/System: A resource failed to call close. 2019-09-04 11:13:55.330 8048-8081/com.example.socialandroidapp D/EGL_emulation: eglMakeCurrent: 0xe1005300: ver 3 0 (tinfo 0xe10036b0) 2019-09-04 11:13:55.334 8048-8081/com.example.socialandroidapp I/chatty: uid=10085(com.example.socialandroidapp) RenderThread identical 1 line 2019-09-04 11:13:55.366 8048-8081/com.example.socialandroidapp D/EGL_emulation: eglMakeCurrent: 0xe1005300: ver 3 0 (tinfo 0xe10036b0) 2019-09-04 11:13:57.057 8048-8153/com.example.socialandroidapp D/com.amazonaws.request: Received error response: com.amazonaws.services.s3.model.AmazonS3Exception: Access Denied (Service: null; Status Code: 403; Error Code: AccessDenied; Request ID: 80D7D91725581D4C), S3 Extended Request ID: dY+iw43vR8nE8DDB4L3F4/ijgC/Ydts/KKgwpwTcplUrtWTuN9GBfAxWcQNIgLRgqW0uR1OEYmA= 2019-09-04 11:13:57.059 8048-8153/com.example.socialandroidapp V/InterceptorCallback: Thread:[1086]: onFailure() S3 upload failed.  Amplify init으로 만들어진 IAM role이 있었습니다. 이 role에 S3 권한을 주어 해결할 수 있습니다.\nAWS console \u0026gt; service \u0026gt; IAM \u0026gt; Role \u0026gt; 검색창에 aws-android-workshop-dev 를 눌러 auth role을 선택합니다.\n권한탭에 정책 연결을 누르세요\n필터 부분에 S3를 입력합니다. 검색된 내용중 AmazonS3FullAccess를 선택하신후 정책 연결 버튼을 누릅니다.\n최종모습은 다음과 같습니다.\n이제 다시 어플리케이션으로 돌아가서 로그아웃 을 하신후 다시 로그인을 하신 후, 글을 작성해 보시기 바랍니다.\n작성 후 다이나모 디비에 들어가 보시면 새로운 item이 추가 된것을 확인 하실 수 있습니다.\nS3에도 마찬가지로 사진이 업로드 된것을 확인 하실 수 있습니다.\n"
},
{
	"uri": "/socialapp/translate/translate/",
	"title": "Translate서비스 연동하기",
	"tags": [],
	"description": "",
	"content": "build.gradle (Module: app) 에 아래와 같이 dependency를 추가 합니다.\ndependencies { ... implementation 'com.amazonaws:aws-android-sdk-translate:2.13.+' }  TRANSLATE 버튼은 각 게시물에 위치합니다. 버튼 클릭이벤트를 이용하여 번역을 하기 위해 PostAdapter의 bindData()에 버튼 클릭이벤트와 리스너를 등록합니다.\nvoid bindData(final ListPostsQuery.Item item) { titleTxt.setText(item.title()); ... //add translateBtn.setOnClickListener(new Button.OnClickListener() { public void onClick(View v) { doTranslate(contentsTxt); doTranslate(titleTxt); } }); }  실제 번역을 담당하는 함수를 bindData() 함수 밑에 작성합니다. AmazonTranslateAsyncClient는 Cognito로부터 얻은AWSCredential을 이용하여 인증합니다.\nprivate void doTranslate(final TextView tv) { AmazonTranslateAsyncClient translateAsyncClient = new AmazonTranslateAsyncClient(ClientFactory.getAWSCredentials()); TranslateTextRequest translateTextRequest = new TranslateTextRequest() .withText(tv.getText().toString()).withTargetLanguageCode(Util.getLanguageCode(ctx)) .withSourceLanguageCode(\u0026quot;auto\u0026quot;); translateAsyncClient.translateTextAsync(translateTextRequest, new AsyncHandler\u0026lt;TranslateTextRequest, TranslateTextResult\u0026gt;() { @Override public void onError(Exception e) { Log.e(TAG, \u0026quot;Error occurred in translating the text: \u0026quot; + e.getLocalizedMessage()); } @Override public void onSuccess(TranslateTextRequest request, TranslateTextResult translateTextResult) { tv.setText(translateTextResult.getTranslatedText()); } }); }  권한탭에 정책 연결을 누르세요\n안드로이드 스튜디오 프로젝트 상단에 실행버튼 을 눌러 이미 생성하신 에뮬레이터로 어플리케이션을 실행합니다. 메인화면에서 SETTINGS 버튼을 통해 화면에 진입합니다.\nPreferred language setting의 list box에서 번역하고자 하는 언어를 선택합니다. (Ex,korean)\nsave 하고 메인화면으로 돌아옵니다. Translate버튼을 눌러 번역이 되는지 확인합니다. 번역이 안되는 것이 맞습니다.\n"
},
{
	"uri": "/socialapp/cognito/cognito-auth-login/",
	"title": "이메일 기반 로그인 기능 구현하기",
	"tags": [],
	"description": "",
	"content": "이번 실습에서는 이메일 기반 로그인 기능을 구현해 보겠습니다.\n아래 코드를 복사하여 이메일 기반 로그인을 수행하는 _signIn 메소드를 완성합니다.\n// LoginActivity.java public class LoginActivity extends AppCompatActivity implements Validator.ValidationListener { ... private void _signIn(String userName, String password) { AWSMobileClient.getInstance().signIn(userName, password, null, new Callback\u0026lt;SignInResult\u0026gt;() { @Override public void onResult(final SignInResult signInResult) { runOnUiThread(() -\u0026gt; { Log.d(TAG, \u0026quot;Sign-in callback state: \u0026quot; + signInResult.getSignInState()); switch (signInResult.getSignInState()) { case DONE: makeToast(context,\u0026quot;Sign-in done.\u0026quot;); CommonAction.openMain(context); break; case SMS_MFA: makeToast(context, \u0026quot;Please confirm sign-in with SMS.\u0026quot;); break; case NEW_PASSWORD_REQUIRED: makeToast(context, \u0026quot;Please confirm sign-in with new password.\u0026quot;); break; default: makeToast(context, \u0026quot;Unsupported sign-in confirmation: \u0026quot; + signInResult.getSignInState()); break; } }); } @Override public void onError(Exception e) { Log.e(TAG, \u0026quot;Sign-in error\u0026quot;, e); runOnUiThread(() -\u0026gt; { if (e instanceof AmazonServiceException) makeToast(context, ((AmazonServiceException) e).getErrorMessage()); }); } }); } ... }  이제 작성한 코드를 실행해 보도록 하겠습니다.\n안드로이드 스튜디오 프로젝트 상단에 실행버튼을 눌러 에뮬레이터로 어플리케이션을 실행합니다. 아래와 같은 화면이 나오면 이메일로 로그인 텍스트를 눌러서 이메일 기반 로그인 메뉴로 이동합니다. 이전 단계에서 가입한 사용자 정보를 활용하여 로그인을 진행해 봅니다. 정상적으로 로그인이 완료된 경우 아래와 같은 앱 메인화면으로 이동하게 됩니다. "
},
{
	"uri": "/socialapp/translate/translateiam/",
	"title": "IAM 권한 주기",
	"tags": [],
	"description": "",
	"content": "번역이 안되는 원인은 logcat에서 다음과 같은 에러, 즉 AccessDenied이 원인입니다.\n2019-09-04 18:00:40.159 10974-11061/com.example.socialandroidapp E/dev-day-item: Error occurred in translating the text: User: arn:aws:sts::539063931014:assumed-role/aws-android-workshop-dev-20190903125208-authRole/CognitoIdentityCredentials is not authorized to perform: translate:TranslateText (Service: AmazonTranslate; Status Code: 400; Error Code: AccessDeniedException; Request ID: af77f01a-f368-4987-96f0-780c7c6ca26d)  Amplify init으로 만들어진 IAM role이 있었습니다. 이 role에 Translate 권한을 주어 해결할 수 있습니다.\nAWS console \u0026gt; service \u0026gt; IAM \u0026gt; Role \u0026gt; 검색창에 aws-android-workshop-dev 를 눌러 auth role을 선택합니다.\n권한탭에 정책 연결을 누르세요\n필터 부분에 Translate를 입력합니다. 검색된 내용중 TranslateFullAccess를 선택하신후 정책 연결 버튼을 누릅니다.\n최종모습은 다음과 같습니다.\n이제 다시 어플리케이션으로 돌아가서 TRANSLATE 버튼을 클릭합니다. 지정된 언어로 변경되는 것을 확인할 수 있습니다.\n"
},
{
	"uri": "/socialapp/pinpoint/amplify-pinpoint/",
	"title": "Amazon Pinpoint 서비스 생성",
	"tags": [],
	"description": "",
	"content": "이제 Amazon Pinpoint 서비스를 amplify 명령어를 이용하여 생성해보도록 하겠습니다.\namplify add notifications  아래와 같이 notification channel로 FCM 을 선택합니다.\nApkKey는 이전 페이지에서 생성한 Cloud Messaging의 server key를 복사하여 붙여 넣습니다.\n생성된 서비스를 push합니다.\namplify push  "
},
{
	"uri": "/socialapp/pinpoint/android-pinpoint/",
	"title": "Push Notification을 위한 안드로이드 코드 작성하기  ",
	"tags": [],
	"description": "",
	"content": "이제 안드로이드 프로젝트에 Push Notification 을 받기 위해 안드로이드 프로젝트와 연동해보도록 하겠습니다.\n우선 build.gradle (Module: Project) 에 아래와 같이 dependencies를 추가 합니다.\ndependencies { ... classpath 'com.google.gms:google-services:4.0.1' ... }  build.gradle (Module: app) 에 plugin을 적용시킵니다.\napply plugin: 'com.google.gms.google-services'  또한 같은 파일에 -build.gradle (Module: app)- 에 아래와 같이 dependency를 추가 합니다.\ndependencies { ... // Overrides an auth dependency to ensure correct behavior implementation 'com.google.android.gms:play-services-auth:15.0.1' implementation 'com.google.firebase:firebase-core:16.0.1' implementation 'com.google.firebase:firebase-messaging:17.3.0' implementation 'com.amazonaws:aws-android-sdk-pinpoint:2.15.+' ... }  AndroidManifest.xml로 이동하여 Push Listener Service를 정의합니다.\n\u0026lt;application\u0026gt; ... \u0026lt;service android:name=\u0026quot;.PushListenerService\u0026quot;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026quot;com.google.firebase.MESSAGING_EVENT\u0026quot;/\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/service\u0026gt; \u0026lt;/application\u0026gt;  Push 메시지를 누르면 App을 open 시키기 위해 아래와 같이 Receiver를 AndroidManifest.xml에 추가합니다.\n\u0026lt;application\u0026gt; ... \u0026lt;receiver android:name=\u0026quot;com.amazonaws.mobileconnectors.pinpoint.targeting.notification.PinpointNotificationReceiver\u0026quot; android:exported=\u0026quot;false\u0026quot; \u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026quot;com.amazonaws.intent.fcm.NOTIFICATION_OPEN\u0026quot; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/receiver\u0026gt; \u0026lt;/application\u0026gt;  MainActivity로 이동하여 Amazon Pinpoint client 생성을 위한 코드를 작성합니다.\npublic class MainActivity extends AppCompatActivity { ... private static PinpointManager pinpointManager; public static PinpointManager getPinpointManager(final Context applicationContext) { if (pinpointManager == null) { final AWSConfiguration awsConfig = new AWSConfiguration(applicationContext); AWSMobileClient.getInstance().initialize(applicationContext, awsConfig, new Callback\u0026lt;UserStateDetails\u0026gt;() { @Override public void onResult(UserStateDetails userStateDetails) { Log.i(\u0026quot;INIT\u0026quot;, userStateDetails.getUserState().toString()); } @Override public void onError(Exception e) { Log.e(\u0026quot;INIT\u0026quot;, \u0026quot;Initialization error.\u0026quot;, e); } }); PinpointConfiguration pinpointConfig = new PinpointConfiguration( applicationContext, AWSMobileClient.getInstance(), awsConfig); pinpointManager = new PinpointManager(pinpointConfig); FirebaseInstanceId.getInstance().getInstanceId() .addOnCompleteListener(new OnCompleteListener\u0026lt;InstanceIdResult\u0026gt;() { @Override public void onComplete(@NonNull Task\u0026lt;InstanceIdResult\u0026gt; task) { if (!task.isSuccessful()) { Log.w(TAG, \u0026quot;getInstanceId failed\u0026quot;, task.getException()); return; } final String token = task.getResult().getToken(); Log.d(TAG, \u0026quot;Registering push notifications token: \u0026quot; + token); pinpointManager.getNotificationClient().registerDeviceToken(token); } }); } return pinpointManager; } ... }  MainActivity의 onCreate함수에서 방금생성한 getPinpointManager함수를 통해 초기화 합니다.\nMainActivity.java\n@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ... // Initialize PinpointManager getPinpointManager(getApplicationContext()); ... }  PushListenerService.java 를 생성하여 Push메시지를 받을 수 있는 서비스를 생성합니다.\npackage com.example.socialandroidapp; import android.content.Intent; import android.os.Bundle; import androidx.localbroadcastmanager.content.LocalBroadcastManager; import android.util.Log; import com.amazonaws.mobileconnectors.pinpoint.targeting.notification.NotificationClient; import com.amazonaws.mobileconnectors.pinpoint.targeting.notification.NotificationDetails; import com.google.firebase.messaging.FirebaseMessagingService; import com.google.firebase.messaging.RemoteMessage; import java.util.HashMap; public class PushListenerService extends FirebaseMessagingService { public static final String TAG = PushListenerService.class.getSimpleName(); // Intent action used in local broadcast public static final String ACTION_PUSH_NOTIFICATION = \u0026quot;push-notification\u0026quot;; // Intent keys public static final String INTENT_SNS_NOTIFICATION_FROM = \u0026quot;from\u0026quot;; public static final String INTENT_SNS_NOTIFICATION_DATA = \u0026quot;data\u0026quot;; @Override public void onNewToken(String token) { super.onNewToken(token); Log.d(TAG, \u0026quot;Registering push notifications token: \u0026quot; + token); MainActivity.getPinpointManager(getApplicationContext()).getNotificationClient().registerDeviceToken(token); } @Override public void onMessageReceived(RemoteMessage remoteMessage) { super.onMessageReceived(remoteMessage); Log.d(TAG, \u0026quot;Message: \u0026quot; + remoteMessage.getData()); final NotificationClient notificationClient = MainActivity.getPinpointManager(getApplicationContext()).getNotificationClient(); final NotificationDetails notificationDetails = NotificationDetails.builder() .from(remoteMessage.getFrom()) .mapData(remoteMessage.getData()) .intentAction(NotificationClient.FCM_INTENT_ACTION) .build(); NotificationClient.CampaignPushResult pushResult = notificationClient.handleCampaignPush(notificationDetails); if (!NotificationClient.CampaignPushResult.NOT_HANDLED.equals(pushResult)) { /** The push message was due to a Pinpoint campaign. If the app was in the background, a local notification was added in the notification center. If the app was in the foreground, an event was recorded indicating the app was in the foreground, for the demo, we will broadcast the notification to let the main activity display it in a dialog. */ if (NotificationClient.CampaignPushResult.APP_IN_FOREGROUND.equals(pushResult)) { /* Create a message that will display the raw data of the campaign push in a dialog. */ final HashMap\u0026lt;String, String\u0026gt; dataMap = new HashMap\u0026lt;\u0026gt;(remoteMessage.getData()); broadcast(remoteMessage.getFrom(), dataMap); } return; } } private void broadcast(final String from, final HashMap\u0026lt;String, String\u0026gt; dataMap) { Intent intent = new Intent(ACTION_PUSH_NOTIFICATION); intent.putExtra(INTENT_SNS_NOTIFICATION_FROM, from); intent.putExtra(INTENT_SNS_NOTIFICATION_DATA, dataMap); LocalBroadcastManager.getInstance(this).sendBroadcast(intent); } /** * Helper method to extract push message from bundle. * * @param data bundle * @return message string from push notification */ public static String getMessage(Bundle data) { return ((HashMap) data.get(\u0026quot;data\u0026quot;)).toString(); } }  이제 코드는 모두 완성이 되었습니다. 안드로이드 스튜디오 프로젝트 상단에 실행버튼 을 눌러 이미 생성하신 에뮬레이터로 실행시키세요. 실행 후 MainActivity화면까지 이동합니다. "
},
{
	"uri": "/socialapp/appsync/android-appsync-query/",
	"title": "게시물 리스트업하기 ",
	"tags": [],
	"description": "",
	"content": "이제 메인 화면에서 사용자가 게시한 화면을 list up 해보도록 하겠습니다.\nMainActivity.java 의 onCreate 함수에서 위에서 ClientFactory 이용하여 AWSAppSyncClient를 생성합니다.\n아래와 같이 ClientFactory.appSyncInit(\u0026hellip;)를 onCreate()함수내에 복사합니다.\n@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); checkPermission(); //appsync ClientFactory.appSyncInit(getApplicationContext()); ... }  onResume()에 아래와 같이 queryList()를 호출하도록 코드를 추가합니다.\nprotected void onResume() { super.onResume(); //appsync queryList(); }  queryList() 함수와 필요한 쿼리 결과를 얻어오는 콜백함수를 아래와 같이 추가합니다.\nprivate PostAdapter mAdapter; public void queryList() { ClientFactory.getAppSyncClient().query(ListPostsQuery.builder() .id(\u0026quot;DEV-DAY\u0026quot;) .sortDirection(ModelSortDirection.DESC) .build()) .responseFetcher(AppSyncResponseFetchers.CACHE_AND_NETWORK) .enqueue(queryCallback); } private ArrayList\u0026lt;ListPostsQuery.Item\u0026gt; mItems; private GraphQLCall.Callback\u0026lt;ListPostsQuery.Data\u0026gt; queryCallback = new GraphQLCall.Callback\u0026lt;ListPostsQuery.Data\u0026gt;() { @Override public void onResponse(@Nonnull Response\u0026lt;ListPostsQuery.Data\u0026gt; response) { Log.e(TAG, response.data().listPosts().items().toString()); mItems = new ArrayList\u0026lt;\u0026gt;(response.data().listPosts().items()); /* Log.i(TAG, \u0026quot;Retrieved list items: \u0026quot; + mItems.toString()); */ runOnUiThread(new Runnable() { @Override public void run() { mAdapter.setItems(mItems); mAdapter.notifyDataSetChanged(); } }); } @Override public void onFailure(@Nonnull ApolloException e) { e.printStackTrace(); } };  List는 RecyclerView를 통해 listup됩니다. RecyclerView에서 사용할 PostAdapter class를 생성합니다.\nPostAdapter.java\npackage com.example.socialandroidapp; import android.content.Context; import android.util.Log; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.Button; import android.widget.ImageView; import android.widget.TextView; import com.amazonaws.ClientConfiguration; import com.amazonaws.Protocol; import com.amazonaws.amplify.generated.graphql.ListPostsQuery; import com.amazonaws.services.s3.AmazonS3Client; import com.squareup.picasso.Picasso; import java.net.URL; import java.util.ArrayList; import java.util.Date; import java.util.List; import androidx.annotation.NonNull; import androidx.recyclerview.widget.RecyclerView; public class PostAdapter extends RecyclerView.Adapter\u0026lt;PostAdapter.Holder\u0026gt; { private static String TAG = \u0026quot;dev-day-item\u0026quot;; private LayoutInflater mInflater; private List\u0026lt;ListPostsQuery.Item\u0026gt; mData = new ArrayList\u0026lt;\u0026gt;(); private Context ctx; PostAdapter(Context context) { ctx = context; this.mInflater = LayoutInflater.from(context); } @NonNull @Override public PostAdapter.Holder onCreateViewHolder(@NonNull ViewGroup viewGroup, int i) { View view = mInflater.inflate(R.layout.post_item, viewGroup, false); Holder holder = new Holder(view); return holder; } @Override public void onBindViewHolder(@NonNull final PostAdapter.Holder holder, int i) { holder.bindData(mData.get(i)); ListPostsQuery.Photo so = mData.get(i).photo(); String bucketName = so.fragments().s3Object().bucket(); String pName = so.fragments().s3Object().key(); ClientConfiguration clientConfig = new ClientConfiguration(); clientConfig.setProtocol(Protocol.HTTP); AmazonS3Client s3 = new AmazonS3Client(ClientFactory.getAWSCredentials(), clientConfig); long d = System.currentTimeMillis() + (2 * 24 * 60 * 60 * 1000); URL url = s3.generatePresignedUrl(bucketName, pName, new Date(d)); final String tmpStr = url.toString(); Log.e(TAG, \u0026quot;URL = \u0026quot; + tmpStr); //new DownloadImageFromInternet(ctx, holder.iv).execute(tmpStr); Picasso.get().load(tmpStr).into(holder.iv); } @Override public int getItemCount() { return mData.size(); } public void setItems(List\u0026lt;ListPostsQuery.Item\u0026gt; items) { mData = items; } public class Holder extends RecyclerView.ViewHolder { private TextView writerTxt, contentsTxt, titleTxt; private ImageView iv; private Button translateBtn; public Holder(View view) { super(view); iv = view.findViewById(R.id.contentImg); writerTxt = view.findViewById(R.id.writer); contentsTxt = view.findViewById(R.id.contents); titleTxt = view.findViewById(R.id.title); translateBtn = view.findViewById(R.id.translateBtn); } void bindData(final ListPostsQuery.Item item) { writerTxt.setText(item.author()); contentsTxt.setText(item.content()); titleTxt.setText(item.title()); } } }  RecyclerView에서 사용할 PostAdapter를 생성하여 연동합니다.\nMainActivity.java의 onCreate()함수 아랫부분에 아래와 같이 작성해주세요\nprotected void onCreate(Bundle savedInstanceState) { ... mAdapter = new PostAdapter(getApplicationContext()); recyclerView = findViewById(R.id.itemlist); recyclerView.setLayoutManager(new LinearLayoutManager(this)); recyclerView.setHasFixedSize(true); recyclerView.setAdapter(mAdapter); }  이제 앱을 실행하면 게시물작성하기에서 만들었던 첫번째 게시물을 확인하실 수 있습니다.\n"
},
{
	"uri": "/devicefarm/fuzzy/",
	"title": "Fuzzy App Test",
	"tags": [],
	"description": "",
	"content": "Fuzzy 테스트를 통해 간단하게 다양한 디바이스에서 테스트를 수행해 봅니다.\n⦁ 테스트 프로젝트를 생성하기 위하여 AWS콘솔로 돌아가 서비스 목록에서 Device Farm을 선택합니다. ⦁ 화면에 +Create a New project를 선택합니다. ⦁ Create project 팝업에서 적절한 Project name을 입력합니다. ⦁ Success문구와 함께 테스트 프로젝트 화면으로 진입하게됩니다. 앱 테스트를 위한 Device Farm project 생성이 완료되었습니다.\n⦁ Create a new run을 선택합니다.\n⦁ 안드로이드와 사과모양 아이콘을 클릭하고, 아래에 Spending되는 항목에서 Upload를 눌러서 이전에 생성해둔 apk파일을 선택합니다. 혹은 파일을 업로드 영역으로 드래그 앤 드랍하여도 됩니다.\n⦁ 업로드가 완료되면 해당 앱에 대한 기본적인 정보가 표출되게 됩니다. 패키지의 도메인네임과 메인 액티비티명, 최소 지원 SDK버전, 지원하는 스크린 사이즈과 같은 정보들이 나열됩니다. Next step을 선택합니다.\n⦁ Configure항목이 나타나며, Test항목에 default로 Built-in: Fuzz로 설정되어있습니다. Event Count는 지 테스트가 수행할 사용자 인터페이스 이벤트 수를 나타내는 1에서 10,000 사이의 숫자를 지정합니다. Event throttle은 퍼지 테스트가 다음 사용자 인터페이스 이벤트를 수행하기 전에 대기할 시간(밀리초)을 나타내는 1에서 1,000 사이의 숫자를 지정합니다. Randomizer seed는 퍼지 테스트가 사용자 인터페이스 이벤트를 임의로 지정할 때 사용할 숫자를 지정합니다. 후속 퍼지 테스트에 동일한 숫자를 지정하면 동일한 이벤트 시퀀스가 보장됩니다.\n⦁ Fuzz테스트 에서는 기본적인 값으로 두고 진행합니다. Next step을 클릭합니다. ⦁ Select devices항목입니다. 기본적으로 Top Devices로 대개 많이 사용되는 기종에 대해 미리 구성된 리스트를 사용합니다. 업로드한 앱이 기종에 호환되는지 여부가 미리 표시되게 됩니다. 케이스에 따라서 Create a new device pool에서 원하는 기종들 OS버전별, Form factor에 따른 테스트 리스트 프리셋을 구성하실 수 있습니다. Next step으로 다음으로 이동합니다.\n⦁ Specify device state 페이지에서는 앱 구동 혹은 테스트에 필요한 추가 파일과 추가 앱을 설정 할 수 있습니다. 또한 WIFI, Bluetooth와 같은 옵션들을 켜거나 끌 수 있습니다. Device location옵션으로 Latitude and Longitude를 임의로 지정 할 수 있습니다. 나머지 값들은 전부 Default로 두고 Next step으로 이동합니다. ⦁ Review and start run항목에서는 실행에 할애 할 최대 시간을 설정 할 수 있습니다. 이는 테스트 할 디바이스들이 예외나 예상치 못한 동작들로 긴 시간동안 떠있는 경우를 방지할 수 있습니다. 본 데모에서는 앱의 기능들이 많지 않고, 짧은 시간에 테스트가 완료되므로 동작 최소시간인 5분으로 설정하겠습니다. 총 5대의 디바이스에 5분씩 동작하여 25분이 소요됩니다. Confirm and start run을 통해 Fuzz테스트를 시작합니다.\n⦁ Fuzz Test 측정 및 결과\n⦁ 위의 단계를 완료하면 project test페이지로 돌아오게 되며, 해당 앱이 테스트 동작중임을 나타내게 됩니다. 동작이 완료되는데에는 아까 설정한 최대 시간 만큼이 소요되게 됩니다.\n⦁ Run 리스트를 눌러 상세에 들어가게 되면 각 디바이스 별 실행 결과와 테스트 단계에서 생성된 스크린 샷을 보여주게 됩니다. Summery형식의 결과표로써 각 디바이스 별 데이터 포인트를 손쉽게 확인 할 수 있습니다. ⦁ 디바이스 리스트 중 하나를 클릭해서 상세로 가게 되면 테스팅 과정에 대한 영상을 열람 할 수 있으며, 각 테스트 단계의 상세한 내역과 로그들을 보거나 다운로드 받을 수 있습니다. ⦁ 특히 Performance내역에는 CPU, Memory 사용량과 Threads지표를 상세히 보여줌으로써 발생할 수 있는 퍼포먼스 이슈에 대한 확인이 가능합니다.\n"
},
{
	"uri": "/devicefarm/remote/",
	"title": "리모트 테스트 실행하기",
	"tags": [],
	"description": "",
	"content": "웹으로 만들어진 앱을 실행해 볼 수 있는 리모트 테스트를 실행 해 봅니다.\n우선 디바이스 팜의 프로젝트를 생성합니다.\n\u0026ldquo;Create a new project\u0026rdquo;를 선택하고 Project name을 적절히 입력합니다.\n생성된 프로젝트 화면에서 \u0026ldquo;Remote access\u0026rdquo;탭을 선택하고 \u0026ldquo;+Start a new session\u0026rdquo;을 선택합니다.\n디바이스 선택화면에서 \u0026ldquo;Show available\u0026hellip;\u0026rdquo; 체크박스를 체크합니다. 이는 30초 이내에 기동할 수 있는 여유가 있는 디바이스만 선택하는 옵션입니다. \u0026ldquo;Name\u0026rdquo; 필드를 통해 원하는 디바이스를 검색 할 수도 있습니다. 적절한 디바이스를 선택합니다.\n화면 최하단의 \u0026ldquo;Confirm and start session\u0026rdquo;을 선택해서 다음으로 진행합니다.\n디바이스를 요청하는 화면이 나오게 됩니다.\n요청이 완료되면 화면에 세션이 나타나게 되고 실제 디바이스를 사용하는 것처럼 제스춰와 스와이프를 할 수 있습니다. 때에따라서 아래에 있는 물리 버튼을 통해 조작을 할 수 있습니다.\n제공되어진 APK파일을 오른쪽 업로드 버튼을 통해 업로드 합니다. 한번 업로드 되어진 APK파일은 30일간 저장되며, 명시적으로 지우기 전까지 언제든 재 사용할 수 있습니다.\n"
},
{
	"uri": "/prerequisites/installtools/",
	"title": "안드로이드 툴 설치하기",
	"tags": [],
	"description": "",
	"content": " Java SDK, Android SDK, and Android Studio가 필요합니다. 설치가 필요하면 아래 링크를 통해 각각 설치하십시요\n참고로 Android SDK, AVD의 버젼은 크게 중요하지 않습니다.\nJava SDK Install Java SDK8.0 이상 설치 되어있지 않다면 Download\nAndroid Studio 및 SDK Install Android Studio 설치되어있지 않다면 Download\n설치과정중 다음과 같이 Android SDK를 함께 인스톨 하세요.\nAndroid AVD (Emulator) Install Android Studio를 설치하신 후 실행합니다. 실행후 다음과 같은 화면에서 AVD Manager 를 선택하세요.\nCreate Virtual Device.을 선택합니다.\nPixel 2 를 선택하시고  Next  를 누르세요.\n설치된 AVD가 하나도 없다면 Pie 나 Q 를 선택하세요. Next  를 누르세요.\n!! 설치시간이 매우 오래 걸립니다. 만약 Oreo, Nougat정도 설치되어 있으면 AVD는 추가 설치 없이 진행해도 됩니다. cancel을 눌러 취소하세요.\nAVD name 을 넣으시고  Finish 를 누르세요.\n"
},
{
	"uri": "/prerequisites/gitclone/",
	"title": "워크샵 저장소 복제하기",
	"tags": [],
	"description": "",
	"content": "오늘 실습에 사용할 소스 파일이 있는 리파지토리를 복사합니다.\ngit clone https://github.com/xmrrh/aws-android-workshop.git  만약 git이 설치되지 않았다면 아래 페이지에 들어가셔서 소스를 download zip하신후 압축을 해제하시면 됩니다.\nhttps://github.com/xmrrh/aws-android-workshop\n"
},
{
	"uri": "/socialapp/",
	"title": "서비스 구성",
	"tags": [],
	"description": "",
	"content": " 서비스 구성 본 워크샵에서 사용되는 Architect는 다음과 같습니다.\n"
},
{
	"uri": "/socialapp/pinpoint/s3iam/",
	"title": "Push 메시지 보내기",
	"tags": [],
	"description": "",
	"content": "Push 메시지는 pinpoint의 campaign을 통해 보내실 수 있습니다. shell에서 아래와 같이 실행하신 후 (콘솔상에서 직접 이동하셔도 됩니다.)\namplify notifications console  AWS console \u0026gt; service \u0026gt; Pinpoint \u0026gt; campaigns \u0026gt; create a campaign  까지 이동합니다.\nCampaign name에 first-push라고 입력하신후 Next 단계로 이동합니다.\nCreate a segment 를 선택하신후 myGroup 라고 이름을 넣습니다. 나머지 설정은 그대로 두신 후 Next 단계로 이동합니다. 우측에 3 endpoints 는 현재 여러분의 앱이 활성화 되어있는 모바일 디바이스의 수를 의미합니다. segment group의 대상이 되는 모바일 디바이스 수이며, filter를 변경하면 endpoint 수가 변경됩니다.\nPush notification details 의 title 과 Body 를 작성하신 후 Next 단계로 이동합니다.\ndefault로 두신 후 Next 단계로 이동합니다.\n맨 아래 Launch campaign 을 누르면 작성된 push 메시지가 각 디바이스로 전송됩니다.\n다음은 Push 메시지를 수신 받은 모습입니다.\n"
},
{
	"uri": "/devicefarm/instrumented/",
	"title": "Espresso Framework를 통한 순차 테스트",
	"tags": [],
	"description": "",
	"content": "Espresso Framework 를 통해 필요한 절차지향적 테스트를 수행합니다.\n⦁ Built-in Espresso test ⦁ Espresso는 기본적으로 내재되어있는 Android Test support library를 기반으로 합니다. Android Studio에 기본 탑재되어있는 Espresso Test Recoder를 통해 간편하게 원하는 순차형식으로 테스트 프리셋을 구성 하실 수 있으며, 이것을 이용하여 Device Farm에서 개발자의 의도대로 앱을 테스트 해 볼 수 있습니다.\n⦁ Android studio로 돌아와서 메뉴 바에서 Run \u0026gt; Record Espresso Test를 선택합니다. ⦁ 앱을 실행 할 때와 마찬가지로 AVD를 선택하는 팝업이 뜨게 됩니다. 앞서 설정했던 디바이스를 선택하고 OK를 누릅니다. ⦁ Record Your Test팝업 창과 더불어 AVD실행 화면이 뜨게 됩니다. 이때 앱 화면에서 동작하는 순서대로 오른쪽 Record List에 기록되게 됩니다. * Add Assertion 기능은 해당 뷰나 텍스트, 화면이 존재하는지 안하는지 확인하는 절차 기능입니다.\n⦁ 예제에서는 ID admin, PASSWORD에 test입력 -\u0026gt; 버튼 1클릭-\u0026gt;버튼2클릭-\u0026gt; POLLYDEMO선택 -\u0026gt;Polly화면에서 test입력후 Read 버튼 선택 -\u0026gt; 뒤로가기 후 종료되는 시나리오로 구성 해 보았습니다.\n⦁ 테스트를 구성 후 OK버튼을 눌러 테스트 코드를 저장합니다. 이름은 Default값으로 진행하겠습니다. ⦁ 메뉴에서 다시 Build \u0026gt; Rebuild Project를 진행하고, Build메뉴의 Build APK(s)를 실행해서 APK를 생성합니다.\n⦁ Espresso Test 로컬 AVD로 실행해보기 ⦁ 우선 로컬에서 Espresso를 통한 순차테스트를 진행해 보겠습니다. 상단 아이콘에서 Edit Confgurations를 선택합니다.\n⦁ Run/Debug Configuraions 팝업에서 Android Instrumented Tests를 선택해서 추가합니다. ⦁ 해당 아이템에서 Name을 지정하고, General 탭의 Module에서 app을 선택합니다. Test항목에서 All in Package를 선택합니다.\n⦁ package에서 해당 앱 패키지를 선택합니다.\n⦁ Prefer Android Virtual Device 항목에서 이전에 생성해둔 AVD를 선택합니다. 그런다음 OK를 누르면 테스트 환경 설정이 완료됩니다.\n⦁ 이제 상단의 Run 메뉴를 확인해 보면 아까 추가했던 테스트 환경구성이 보일 것입니다. 환경구성을 선택하고 Run하게 되면, 기존의 앱을 AVD로 실행하던 것과 같이 디바이스가 실행되고 난 후, 앱이 실행되면 아까 기록했던 동작들을 차례로 수행하게 됩니다\n⦁ Run Console을 확인해보면, 성공적으로 테스트를 수행 후 Tests ran to completion. 이라는 메세지를 확인 할 수 있습니다.\nv\n⦁ 이로써 Built-in test framework인 espresso를 설정하고, 이를 통해서 로컬 AVD에서 테스트를 수행 해 보았습니다. 다음 챕터에서는 Device farm을 통해 espresso 테스트를 수행하고 결과를 모니터링 해 보겠습니다.\n⦁ Device Farm을 통한 Espresso Test 실행 및 결과 모니터링 ⦁ 전반적인 절차는 앞서 시행했던 Fuzz 테스트와 비슷합니다. Device Farm 콘솔로 다시 와서 Fuzz를 실행했던 프로젝트 목록에서 +Create a new project를 선택합니다. ⦁ +Create a new run을 선택합니다.\n⦁ Choose application 단계에서 안드로이드/애플 을 선택해주세요. ⦁ Upload 버튼에서 빌드된 Apk를 업로드 하거나, 앞서 업로드 했던 리스트에서 선택합니다. Next step으로 다음으로 진행합니다.\n⦁ Configure your test설정 화면에서 Test유형을 Instrumentation으로 설정합니다.\n⦁ 이제 Espresso로 생성된 instrumentation test를 업로드 해야 합니다. 일반적은 테스트 패키지의 경로는 프로젝트명/ /app/build/outputs/apk/androidTest/debug/app-debug-androidTest.apk에 빌드되어 있습니다. 혹은 해당위치가 없거나 잘 모르시겠다면 이전 단계 로컬 테스트에서 출력되는 내용에 해당 경로에 대한 내용이 있으니 참고하시면 됩니다. * 하단의 Advanced Configuration (optional)은 테스트에 대한 비디오 기록 및 App Performance 데이터에 대한 모니터링 여부를 위한 것입니다. Default로 두시면 됩니다.\n⦁ 업로드가 완료되면 Test instrumentation에 대한 정보가 표출됩니다. 기본 패키지에 대한 도메인 정보와, Runner에 대한 정보가 표시됩니다. 여기서는 espresso가 junit기반이므로 AndroidJUnitRunner로 표시됩니다. 하단의 Test filter에 대한 enviroment설정은 그대로 두고 Next step으로 진행합니다. ⦁ Select devices에는 기존 Fuzz테스트와 마찬가지로 Top Devices로 설정하겠습니다. 때에 따라서 원하는 기종으로 구성하시거나 테스트시간을 단축하고자 한다면, 몇개의 기종으로 테스트를 하신다면 좋을 것입니다. 각 기종에 대한 해당 테스트 앱 패키지의 호환성을 체크하고, Next step으로 진행합니다. ⦁ Sepecify device state는 default로 진행합니다. 혹여 테스트 상에 한글에 대한 호환성이 필요하시면 Device locale에 Korean (ko_KR)로 설정합니다. 다음 단계로 진행합니다.\n⦁ 테스트 진행에 대한 Summery를 보실 수 있으며, Execution timeout에서 MAXIMUM MINUTES PER DEVICE를 5분으로 설정합니다. Confirm and start run을 실행 해 줍니다. ⦁ 이제 Run list에 해당 테스트 작업이 진행되고, 평균 10분내외에 작업이 완료됩니다.\n⦁ Devices 목록에서 상세를 보시면 로컬에서 실행했던 순차 테스트 그대로 돌아가는 모습을 확인 할 수 있습니다.\n"
},
{
	"uri": "/prerequisites/workspace/",
	"title": "안드로이드 스튜디오 프로젝트 생성",
	"tags": [],
	"description": "",
	"content": "안드로이드 스튜디오 를 시작합니다.\nOpen an existing Android Studio project 를 선택합니다.\n다운받은 소스 디렉토리를 지정합니다.\n프로젝트가 생성이 되면 다음과 같은 모습이어야 합니다. 빌드에 문제가 없음을 확인하세요 안드로이드 스튜디오 프로젝트 상단에 실행버튼 을 눌러 이미 생성하신 에뮬레이터로 실행시키세요. 아래와 같이 보이면 됩니다. 이제 실습을 위한 사전 준비는 완료되었습니다. 이제 AWS 서비스를 이용하여 하나씩 기능을 완성해 보도록 하겠습니다.\n"
},
{
	"uri": "/socialapp/translate/",
	"title": "Amazon Translate 연동하기",
	"tags": [],
	"description": "",
	"content": " Amazon Translate 연동하기 이제 게시물의 제목과 내용을 다양한 언어로 번역할 수 있는 Amazon Translate을 연동해 보도록 하겠습니다.\n"
},
{
	"uri": "/socialapp/pinpoint/",
	"title": "Push 메시지 보내기",
	"tags": [],
	"description": "",
	"content": " Push 메시지 보내기 Amazon Ponpoint를 활용하여 App이 설치된 사용자에게 PUSH notification을 보내는 방법을 실습해보겠습니다.\n"
},
{
	"uri": "/cleanup/",
	"title": "클린 업",
	"tags": [],
	"description": "",
	"content": " 클린업 이번 워크샵에서 사용한 리소스를 삭제합니다.\n"
},
{
	"uri": "/devicefarm/",
	"title": "DeviceFarm 테스트",
	"tags": [],
	"description": "",
	"content": " DeviceFarm 테스트 빌드 된 앱을 DeviceFarm으로 간단히 구동해보고, 병렬 테스트를 수행합니다. 이 테스트에서는 Fuzzy 테스트와 Frame Work 순차 테스트를 진행합니다.\n\n"
},
{
	"uri": "/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/example_cf_templates/",
	"title": "Example of using CloudFormation Templates",
	"tags": [],
	"description": "",
	"content": " Click below to add a CloudFormation Stack    Use these templates:       Template 1 example \u0026lt;a     href=\u0026ldquo;https://console.aws.amazon.com/cloudformation/home?#/stacks/create/review?stackName=\u0026amp;templateURL=https://s3.amazonaws.com/awsandroidworkshop.com/templates/master/example1.yml\u0026quot; target=\u0026rdquo;_blank\u0026rdquo; class=\u0026ldquo;btn btn-default\u0026rdquo;\u0026gt;  Launch  |  Download  | | Template 2 example |  Launch  |  Download  | | Template 3 example |  Launch  |  Download  |\n"
},
{
	"uri": "/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]